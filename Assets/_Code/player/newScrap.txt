using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using Magical;
using MathsAndSome;
using Globals;
using Elements;
using UnityEngine.InputSystem;

namespace Player {

	[RequireComponent(typeof(AudioSource))]
	public class PL_Controller : RB_Controller {


		[Header("Movement")]
		public float 					forwardSpeed 		= 12f;
		public float 					sidewaysSpeed 		= 12f;

		
		[Header("Jumping")]
		public bool canJump;
		public float 					jumpForce;
		[SerializeField] float 			groundedRange 		= 1.08f;

		
		[Header("Slam")]

		public bool canSlam;
		
		
		[Header("Mouse")]

		public float 					mouseSensitivityX;
		public float 					mouseSensitivityY;
		
		[SerializeField] float 			maxY				= 90;
		[SerializeField] float 			minY 				= -90;
		
		float 							currentXRotation;

		[Header("States")]

		public PlayerState 				state;
		public MovementState 			jumpState 			= MovementState.none;
		public MovementState 			slideState 			= MovementState.none;
		public MovementState 			slamState 			= MovementState.none;

		[Header("Stamina")]

		public Stamina stamina;
		


		[HideInInspector] public Camera playerCamera;
		[SerializeField] CapsuleCollider collider;
		float 							playerHeight => collider.height;
		//
		
		
		float hInp;
		float vInp;
	
		public GameObject forwardObject;


		public override void SetStartDefaults() {
			base.SetStartDefaults();

		
			playerCamera = Camera.main;
			Cursor.lockState = CursorLockMode.Locked;
			Cursor.visible = false;
		}

		public override void FixedUpdate() {
			if (state != PlayerState.sliding && state != PlayerState.slamming && canMove) this.Move();
		}

		public override void Update() {
			base.Update();
			HandleMouse();
        }







		void SetAdminMode() {
			// ResetForces();
			// forwardSpeed = defaultSpeed * 2;
			// adminState = AdminState.noclip;
			transform.GetChild(0).GetComponent<CapsuleCollider>().isTrigger = true;
			rb.useGravity = false;
		}

		void SetStandardMode() {
			// forwardSpeed = defaultSpeed;
			// adminState = AdminState.standard;
			transform.GetChild(0).GetComponent<CapsuleCollider>().isTrigger = false;
			rb.useGravity = true;
		}







		public new void Move() {
			

			if (!Grounded()) {
				hInp = Input.GetAxis("Horizontal");
				vInp = Input.GetAxis("Vertical");
				Debug.Log("NON");
			}

            else {
                hInp = Input.GetAxisRaw("Horizontal");
				vInp = Input.GetAxisRaw("Vertical");
				Debug.Log("Raw");
            }

			Vector3 forward = forwardObject.transform.forward;
			Vector3 right = forwardObject.transform.right;

			Vector3 force = (forward * vInp * (forwardSpeed * 100)) + (right * hInp * (sidewaysSpeed * 100));
			rb.AddForce(force);

		}

		public IEnumerator ManageSlidePlayerHeight() {
			collider.GetComponent<CapsuleCollider>().height = playerHeight / 4;

			collider.transform.position = new(
				collider.transform.position.x,
				collider.transform.position.y - (playerHeight / (4 * 3 / transform.localScale.y)),
				collider.transform.position.z
			);

			yield return new WaitUntil(() => magic.key.up(keys.slide));

			collider.GetComponent<CapsuleCollider>().height = playerHeight;

			collider.transform.position = new(
				collider.transform.position.x,
				collider.transform.position.y + (playerHeight / (4 * 3 / transform.localScale.y)),
				collider.transform.position.z
			);
		}



		public bool Grounded() => Physics.Raycast(collider.transform.position, Vector3.down, transform.localScale.y * groundedRange);
		


		void HandleMouse() {
			float mouseX = Input.GetAxisRaw("Mouse X") * mouseSensitivityX;
			float mouseY = Input.GetAxisRaw("Mouse Y") * mouseSensitivityY;

			transform.Rotate(Vector3.up * mouseX);

			currentXRotation -= mouseY;
			currentXRotation = Mathf.Clamp(currentXRotation, minY, maxY);

			playerCamera.transform.localRotation = Quaternion.Euler(currentXRotation, 0f, 0f);
		}
	

	
		void AdminMove() {
			hInp = Input.GetAxisRaw("Horizontal");
			vInp = Input.GetAxisRaw("Vertical");

			Vector3 right = playerCamera.transform.right;
			Vector3 forward = playerCamera.transform.forward;

			rb.linearVelocity = (forward * vInp + right * hInp).normalized * forwardSpeed;

			if (magic.key.gk(keys.jump)) rb.linearVelocity = new(rb.linearVelocity.x, 30, rb.linearVelocity.z);
			if (magic.key.gk(keys.dash)) rb.linearVelocity = new(rb.linearVelocity.x, -30, rb.linearVelocity.z);
			if (magic.key.down(keys.teleport)) {
				if (Physics.Raycast(transform.position, playerCamera.transform.forward, out RaycastHit hit, 1000f)) {
					transform.position = hit.point;
				}
			}
		}
		
	}
}